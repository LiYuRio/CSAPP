# 优化程序性能

> 专注于梳理本章中出现的重要概念，对概念的描述尽量做到述而不作，避免因为个人理解偏差对其他人造成误导。
>
> 本章主要介绍如何使用几种不同类型的程序优化技术，在程序运行正确的基础上，使程序运行的更快。

* 编写高效程序的方法论

  * 选择一组适当的数据结构和算法
  * 必须编写出编译器能够有效优化以转换成高效可执行代码的源代码，理解编译器的能力和局限性很重要（比如C语言中执行指针运算和强制类型转换就很难被编译器优化）
  * 针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合上并行的计算

* 妨碍优化的因素（optimization blocker）

  程序行为中那些严重依赖于执行环境的方面，比如可能出现的内存别名使用、函数调用等。

* 汇编代码 VS 重写程序

  使用汇编代码，固然也可以达到优化程序性能的目的，但是汇编代码具有比较强的平台依赖性，不容易移植。相比于另一种方法，不断重写程序直到编译器由此可以产生有效的代码为止，虽然性能不一定是最好的，但是得到的代码可以在其他机器上运行。

* 现实中，对代码的优化不是一帆风顺的

  优化需要很多的试错实验，一些看上去很小的变化会导致性能上很大的变化，而性能可能依赖于处理器设计的许多细节特性，对此我们所知甚少，所以要想让编译器尽可能的产生有效代码，需要

  * 尝试各种技术的变形和组合
  * 理解编译器产生的汇编代码，在此基础上，修改源代码
  * 循环修改代码，分析性能，使编译产生的代码尽可能的好



## 优化编译器的能力和局限性

* 编译器提供的优化控制

  现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是如何被使用的，然后会利用一些机会来简化表达式。

  大多数编译器，向用户提供了一些对它们所使用的优化的控制，最简单的优化控制优化级别，比如`-Og`、`-O1`、`-O2`等。

* 安全的优化

  对于程序可能遇到的所有可能的情况，保证优化后得到的程序和未优化的版本有一样的行为。

  编译器只对程序进行安全的优化，在优化过程中，考虑妨碍优化的因素。

  * 内存别名使用

    程序中的两个指针可能指向同一个内存位置。如果编译器不能确定两个指针是否指向了同一个位置，就必须假设什么情况都有可能，这就限制了可能的优化策略。

  * 函数调用

    函数的执行过程中可能会修改全局程序状态的一部分，改变调用函数的次数会改变程序的行为，所以大多数编译器不会试图判断一个函数是否没有副作用，而会直接假设是最糟的情况，并保持所有函数的调用不变。

* 用**内联函数替换**（inline substitution）优化函数调用

  直接将函数调用替换成函数体本身。这样转换既减少了函数调用的开销，也允许对展开代码做进一步的优化。

  在GCC中，可以使用命令行选项`-finline`指示，或者使用优化等级`-O1`及以上，但是GCC只尝试在单个文件中定义的函数的内联，也就是说它无法处理一组库函数在一个文件中被定义，却被其他文件内的函数所调用。

  不过使用内联函数替换会影响符号调试器追踪或者设置断点。

## 表示程序性能

* 时钟频率/时钟周期

  通常用千兆赫兹（GHz）来表示，即十亿周期每秒，比如一个系统有”4GHz“处理器，这表示处理器时钟运行频率为每秒$4\times 10^9$个周期，每个周期的时间是时钟频率的倒数。

* 每元素的周期数（Cycles Per Element, CPE）

  以”前缀和“为例，随着运算的数据规模的增加，一个过程所需要的时间（以时钟周期为单位）可以用一个常数加上一个与被处理元素个数成正比的因子来描述，这个系数就是CPE的有效值。

## 程序示例

* C语言里面的宏定义`#define`真的很强啊，以前都不知道还可以直接定义操作的，例如

  ```c
  #define OP +
  int main() {
    int a = 1;
    int b = 2;
    int c = a OP b;
    printf("%d\n", c);
  }
  ```

* 养成使用编译器的级别优化是一个好习惯

  未经优化的代码是从C语言到机器代码的直接翻译，通常效率明显比较低，简单的使用命令行选项`-O1`，就会进行一些基本的优化，程序员不需要做什么，就可以达到一定的优化效果。
  
* 一个优化示例

  使用某种运算，将一个向量中所有的元素合并成一个值。通过使用编译时常数IDENT和OP的不同定义，该代码可以重新编译成对数据执行不同的运算。下面是`combine1`的代码，书中后面提到的优化方案都是基于这个代码做实验的。

  ```c
  #define OP +
  #define IDENT 0
  void combine1(vec_ptr v, data_t *dest) {
  	 long i;
  	 *dest = IDENT;
  	 for (i = 0;i < vec_length(v);i++) {
  	 	data_t val;
  	 	get_vec_element(v, i, &val);
  	 	*dest = *dest OP val;
  	 }
  }
  ```

## 消除循环的低效率

* 代码移动（code motion）

  比较常见的优化方法，这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算，将计算移动到代码前面不会被多次求值的部分。

  优化编译器虽然会试着进行代码移动，但是对于会改变在哪里调用函数或调用多少次的变换，编译器通常会非常小心。它们不能可靠地发现一个函数是否会有副作用，因而假设函数会有副作用。

  ```c
  /* 把调用vec_length函数移动到循环外 */
  void combine2(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    
    *dest = IDENT;
    for (i = 0; i < length;i++) {
      data_t val;
  	 	get_vec_element(v, i, &val);
  	 	*dest = *dest OP val;
    }
  }
  ```

* 库函数strlen的实现

  虽然strlen通常是用特殊的x86字符串处理指令来实现的，但是它的整体执行还是需要一步一步检查整个序列，直到碰到结尾的null为止。如果在一个循环体中以调用`strlen()`函数作为判断停止的条件，那么会使得整体运行时间变成字符串长度的二次项。

## 减少过程调用

* 以从数组中读取指定下标的元素为例

  如果通过调用一个函数来获取指定元素，那每次都需要把索引和循环边界做比较。如果按顺序访问数组中的元素，且明确不会越界，那么每次做判断会导致低效率。（但是因为其他一些限制因素，这样修改后没有带来太大的性能提升）

  ```c
  data_t *get_vec_start(vec_ptr v) {
    return v->data;
  }
  
  /* 直接访问数组元素 */
  void combine3(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    
    *dest = IDENT;
    for (i = 0; i < length;i++) {
  	 	*dest = *dest OP data[i];
    }
  }
  ```

## 消除不必要的内存引用

* 在累积求值时，不需要每次都把中间结果写到内存中，读/写内存的开销是很大的。

  ```c
  /* 在局部变量中进行结果的累加 */
  void combine4(vec_ptr v, data_t *dest) {
    long i;
    long length = vec_length(v);
    data_t *data = get_vec_start(v);
    data_t acc = IDENT;
    
    for (i = 0; i < length;i++) {
  	 	acc = acc OP data[i];
    }
    *dest = acc;
  }
  ```

  给编译器加优化编译参数，并不会对`combine3`中的内存访问进行自动优化，因为可能存在之前所说的内存别名问题，比如若定义`dest=get_vec_start(v) + 2`，调用`combine3`和`combine4`会产生不一样的结果。





