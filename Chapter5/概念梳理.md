# 优化程序性能

> 专注于梳理本章中出现的重要概念，对概念的描述尽量做到述而不作，避免因为个人理解偏差对其他人造成误导。
>
> 本章主要介绍如何使用几种不同类型的程序优化技术，在程序运行正确的基础上，使程序运行的更快。

* 编写高效程序的方法论

  * 选择一组适当的数据结构和算法
  * 必须编写出编译器能够有效优化以转换成高效可执行代码的源代码，理解编译器的能力和局限性很重要（比如C语言中执行指针运算和强制类型转换就很难被编译器优化）
  * 针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和多处理器的某种组合上并行的计算

* 妨碍优化的因素（optimization blocker）

  程序行为中那些严重依赖于执行环境的方面，比如可能出现的内存别名使用、函数调用等。

* 汇编代码 VS 重写程序

  使用汇编代码，固然也可以达到优化程序性能的目的，但是汇编代码具有比较强的平台依赖性，不容易移植。相比于另一种方法，不断重写程序直到编译器由此可以产生有效的代码为止，虽然性能不一定是最好的，但是得到的代码可以在其他机器上运行。

* 现实中，对代码的优化不是一帆风顺的

  优化需要很多的试错实验，一些看上去很小的变化会导致性能上很大的变化，而性能可能依赖于处理器设计的许多细节特性，对此我们所知甚少，所以要想让编译器尽可能的产生有效代码，需要

  * 尝试各种技术的变形和组合
  * 理解编译器产生的汇编代码，在此基础上，修改源代码
  * 循环修改代码，分析性能，使编译产生的代码尽可能的好



## 优化编译器的能力和局限性

* 编译器提供的优化控制

  现代编译器运用复杂精细的算法来确定一个程序中计算的是什么值，以及它们是如何被使用的，然后会利用一些机会来简化表达式。

  大多数编译器，向用户提供了一些对它们所使用的优化的控制，最简单的优化控制优化级别，比如`-Og`、`-O1`、`-O2`等。

* 安全的优化

  对于程序可能遇到的所有可能的情况，保证优化后得到的程序和未优化的版本有一样的行为。

  编译器只对程序进行安全的优化，在优化过程中，考虑妨碍优化的因素。

  * 内存别名使用

    程序中的两个指针可能指向同一个内存位置。如果编译器不能确定两个指针是否指向了同一个位置，就必须假设什么情况都有可能，这就限制了可能的优化策略。

  * 函数调用

    函数的执行过程中可能会修改全局程序状态的一部分，改变调用函数的次数会改变程序的行为，所以大多数编译器不会试图判断一个函数是否没有副作用，而会直接假设是最糟的情况，并保持所有函数的调用不变。

* 用**内联函数替换**（inline substitution）优化函数调用

  直接将函数调用替换成函数体本身。这样转换既减少了函数调用的开销，也允许对展开代码做进一步的优化。

  在GCC中，可以使用命令行选项`-finline`指示，或者使用优化等级`-O1`及以上，但是GCC只尝试在单个文件中定义的函数的内联，也就是说它无法处理一组库函数在一个文件中被定义，却被其他文件内的函数所调用。

  不过使用内联函数替换会影响符号调试器追踪或者设置断点。

## 表示程序性能

* 时钟频率/时钟周期

  通常用千兆赫兹（GHz）来表示，即十亿周期每秒，比如一个系统有”4GHz“处理器，这表示处理器时钟运行频率为每秒$4\times 10^9$个周期，每个周期的时间是时钟频率的倒数。

* 每元素的周期数（Cycles Per Element, CPE）

  以”前缀和“为例，随着运算的数据规模的增加，一个过程所需要的时间（以时钟周期为单位）可以用一个常数加上一个与被处理元素个数成正比的因子来描述，这个系数就是CPE。