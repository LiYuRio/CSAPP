# 处理器体系结构

> 专注于梳理本章中出现的重要概念，对概念的描述尽量做到述而不作，避免因为个人理解偏差对其他人造成误导。
>
> 本章将简要介绍处理器硬件的设计，研究一个硬件系统执行某种ISA指令的方法。

* 指令集体系结构（Instruction Set Architecture，ISA）

  * 描述一个处理器**支持的指令**和**指令的字节级编码**。
  * 为编译器编写者和处理器设计者提供概念抽象层。（相当于一层封装解耦）
  * 不同处理器家族有不同的指令集体系结构，如`x86-64`、`ARM`。

* Y86-64指令集

  受x86-64指令集的启发，创建该简化指令集。与x86-64指令集相比；

  * 数据类型、指令和寻址方式比较少
  * 字节级编码比较简单
  * 机器代码相对不那么紧凑，CPU译码逻辑也相对简单
  * 但结构完整，可以写一些处理整数的程序

* 硬件控制语言（HCL）

  描述硬件系统控制部分的简单语言。

## Y86-64指令集体系结构

> 定义Y86-64指令集体系结构中的各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

* 程序员可见状态

  程序中的每条指令都会读取或修改处理器状态的某些部分。Y86-64的程序员可见状态包括：

  * 15个程序寄存器，每个程序寄存器存储一个64位的字。存储在CPU中的一个寄存器文件中。

  * 程序寄存器的指示符字节编码如下表所示

    | 程序寄存器   | ID   |
    | :----------- | :--- |
    | %rax         | 0    |
    | %rcx         | 1    |
    | %rdx         | 2    |
    | %rbx         | 3    |
    | %rsp         | 4    |
    | %rbp         | 5    |
    | %rsi         | 6    |
    | %rdi         | 7    |
    | %r8          | 8    |
    | %r9          | 9    |
    | %r10         | A    |
    | %r11         | B    |
    | %r12         | C    |
    | %r13         | D    |
    | %r14         | E    |
    | 无寄存器访问 | F    |

  * 程序计数器（PC）

  * 条件码寄存器：包括3个一位的条件码，ZF、SF和OF。保存最近的算术或逻辑指令所造成影响的有关信息。

  * 内存，用虚拟地址指明数据实际在内存中的存储位置。

  * 状态码（Stat）：程序执行的整体状态。

* Y86-64指令

  * 将MOV指令根据目的和源的格式，分为4种，不支持内存间和立即数到内存的传送。
  * 整数操作指令，分为4种
  * 根据分支指令的类型和条件代码的设置来选择分支，跳转指令分为7种。目的地址采用绝对编码方式（相比于IA32的相对寻址方式）
  * 条件传送指令，分为6种，只有条件码满足所需要的约束时，才会更新目的寄存器的值
  * 函数的调用和返回指令，调用指令的目的地址采用绝对编码方式（相比于IA32的相对寻址方式）
  * 与栈操作相关的入栈和出栈指令
  * 停止指令的执行的指令
  * 空指令

  <img src="images/Y86-64指令集.png" alt="Y86-64指令集" style="zoom:80%;" />

* Y86-64指令编码由1~10个字节组成。

  * 第一个字节：指令的类型
    * 高4位代表代码
    * 低4位代表功能，区分共用代码的相关指令
  * 第二个字节：寄存器指示符字节，具体和程序寄存器表中的字节表示对应。
  * 后四个字节：常数字，代表操作数或绝对地址。
  * 指令中的所有整数采用小端法编码，即当按照反汇编格式书写，字节以相反的顺序出现。
  * 字节编码和指令必须一一对应。
  
* CISC和早期的RISC

  | CISC                                                         | 早期的RISC                                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 指令数量很多                                                 | 指令数量少很多，通常少于100个。                              |
  | 有些指令的延迟很长，如将一整块从内存的一部分复制到另一部分   | 没有较长延迟的指令，有些早期的RISC机器甚至没有整数乘法指令。 |
  | 编码是可变长度的，x86-64的指令长度通常是1~15个字节           | 编码是固定长度的，通常所有指令都编码为4个字节                |
  | 指定操作数的方法有很多                                       | 简单寻址方式，通常只有基址和偏移量寻址                       |
  | 可以对内存和寄存器操作数进行算术和逻辑运算                   | 只能对寄存器操作进行算术逻辑运算，允许使用内存的只有load和store指令，这种方法称为load/store体系 |
  | 对机器级程序来说，实现细节是不可见的，ISA提供程序和如何执行程序之间的清晰的抽象。 | 对机器级程序来说实现细节是可见的                             |
  | 有条件码，作为指令执行的副产品，设置了一些特殊的标志位，可以用于条件分支检测。 | 没有条件码，对条件检测来说，要明确测试指令，将测试结果放在一个普通寄存器中。 |
  | 栈密集的过程链接，栈被用来存取过程参数和返回地址             | 寄存器密集的过程链接，因此有些过程能完全避免内存引用。       |

  Y86-64指令集可以看成是采用CISC指令集，但又根据某些RISC的原理进行了简化。

* Y86-64指令集状态码（Stat）可能的值

  | 状态码值 | 名字 | 含义                            |
  | -------- | ---- | ------------------------------- |
  | 1        | AOK  | 正常操作                        |
  | 2        | HLT  | 处理器执行halt指令              |
  | 3        | ADR  | 处理器遇到非法内存地址（读/写） |
  | 4        | INS  | 处理器遇到非法指令代码          |

  除AOK外，状态码等于其他值都意味着，硬件在执行指令时遇到异常，有两种解决方法：

  * 简单粗暴的让处理器停止程序的运行。（Y86-64采用这种方法）
  * 让处理器调用异常处理程序，根据配置的不同结果，中止程序或者调用一个用户自定义的信号处理程序。

* 一个基于Y86-64指令集运行程序的全过程

  * 使用Y86-64定义的指令规则编写对应的汇编代码。其中包含指令、伪指令（指明应该将代码或数据放在什么位置以及如何对齐）、数据。
  * 将汇编代码输入YAS汇编器，输出目标代码。目标代码包含一个地址，后面跟着1~10个字节的值。
  * 通过指令模拟器YIS，模拟Y86-64机器代码程序的执行，而不用去模拟任何具体处理器实现的行为，有助于在有实际硬件可用之前调试程序。

* 两个会对设计产生歧义的指令

  * `pushq %rsp`

    压入的是%rsp寄存器的原始值

  * `popq %rsp`

    将%rsp设置为从内存中读出的值

## 逻辑设计和硬件控制语言HCL

> 在底层硬件实现中，用电子电路来对应进行运算函数，以及在各种存储器单元中存储位。所以设计一个数字系统需要考虑以下三个组成部分的逻辑设计：
>
> * 计算对位进行操作的函数的组合逻辑
> * 存储位的存储器单元
> * 控制存储器单元进行更新的时钟信号
>
> 同时为了方便电路的设计工作，推出硬件控制语言（HCL）来抽象描述不同处理器设计的控制逻辑。

* 数字电路的基本计算单元——逻辑门

  * 逻辑门的输出等于输入位值的某个布尔函数，只对单个位的数进行操作
  * HCL写法为：`&&`、`||`、`!`（与、或、非）
  * 逻辑门总是活动的，一旦一个门的输入发生变化，在短时间内，输出也会发生变化。

* 组合电路

  将很多的逻辑门组合成一个网，就能构建计算块，这个计算块被称为组合电路。组合电路的构建有以下三个限制：

  * 这个网必须是无环的。
  * 两个或多个逻辑门的输出不能连接到一起。
  * 每个逻辑门的输入必须连到，一个系统输入、某个存储器单元的输出或者某个逻辑门的输出。

* 多路复用器（multiplexor）

  根据输入的控制信号的值，从一组不同的数据信号中选出一个。下图所示是一个但各位的多路复用器的电路

  <img src="images/单个位的MUX.png" alt="单个位的MUX" style="zoom:80%;" />

* 字级的组合电路

  根据输入字的各个位，用逻辑门来计算输出字的各个位。

* 多路复用器的HCL描述——情况表达式

  ```
  [
  	select1 : expr1
  	select2 : expr2
  	...
  	selectk : exprk
  ]
  ```

  每种情况都包含一个布尔表达式和一个整数表达式，前者表示什么时候选择这个情况，后者表示得到的值。布尔表达式顺序求值，第一个求值为1的情况被选中。

* 算术/逻辑单元（ALU）

  在字级数据上执行许多不同类型的操作的组合逻辑电路，ALU有两个数据输入和一个控制输入，根据控制输入的设置，电路会对数据输入执行不同的算术逻辑运算，Y86-64指令集支持的四种不同的整数运算的ALU抽象表示如下图所示：

  <img src="images/Y86-64的ALU.png" alt="Y86-64的ALU" style="zoom:80%;" />

* 集合关系的HCL描述

  * 应用场景：在处理器的设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。

  * 通用格式为

    ```
    iexpr in {iexpr1, iexpr2, ..., iexprk
    ```

    其中iexpr为整数表达式。

* 时序电路

  电路中存有状态，并且在这个状态上进行计算的系统。需要引入按位存储信息的设备，存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候把新值加载到设备中，以下是两类存储器设备：

  * 时钟寄存器存储单个位或字。时钟信号控制寄存器加载输入值
  * 随机访问存储器存储多个字
    * 虚拟内存（数据内存和指令内存）
    * 寄存器文件

* 硬件寄存器和程序寄存器

  * 硬件寄存器：直接将寄存器的输入输出线连接到电路的其他部分。大多数时候，寄存器都保持在一个稳定的状态，产生的输出值等于它的当前状态。只有当时钟变成高电位的时候，新的输入信号才会加载到寄存器中，成为该寄存器下一个稳定的状态。

    <img src="images/寄存器操作.png" alt="寄存器操作" style="zoom:80%;" />

  * 程序寄存器：CPU中为数不多的可寻址的字

* 寄存器文件

  <img src="images/寄存器文件.png" alt="寄存器文件" style="zoom:80%;" />

  * 两个读端口A和B，当srcA或srcB被设置为某个寄存器ID时，在一段延迟后，存储在相应程序寄存器的值就会出现在valA或valB上。
  * 一个写端口W，向寄存器文件写入字是由时钟信号控制的，控制方法类似于将值加载到时钟寄存器。当dstW设置为特殊的ID值0xF时，不会写任何程序寄存器。

* 随机访问存储器

  <img src="images/随机访问存储器.png" alt="随机访问存储器" style="zoom:80%;" />

  * 一个地址输入，一个写的数据输入，以及一个读的数据输出
  * write控制信号为0，读输入地址上的数据，如果地址超出了范围，error信号会设置为1，否则为0。
  * write控制信号为1，写输入地址上的数据，如果地址超出了范围，error信号会设置为1，否则为0。
  * error信号是由组合逻辑产生的，因为边界检查并不涉及保存状态。

## Y86-64的顺序实现

> 在上一节引入算术/逻辑单元（ALU）、时钟寄存器、随机访问存储器的基础上，描述如何实现一个SEQ（顺序的）处理器。
>
> SEQ处理器的典型特点是：在每个时钟周期上，SEQ执行处理一条完整指令所需的所有步骤。

* 将指令操作分为相同阶段的通用框架

  * 原理：给每个指令对应一套硬件逻辑实现是不靠谱的，在设计硬件时，有一个非常简单且一致的结构非常重要，希望硬件数量尽可能的少，并最终将它映射到一个二维集成电路芯片的表面。不过这样就额外需要，控制逻辑在这些单元之前路由信号，并根据指令类型和分支条件产生适当的控制信号。

  * 降低硬件复杂度的方法：让不同指令共享尽量多的硬件。
  * 六层通用处理框架
    * 取值：取指阶段从内存中读取指令字节，读取地址为当前PC的值。
      * 得到指令指示符字节，包括指令代码（icode）和指令功能（ifun）两个部分。
      * 得到寄存器指示符字节，包括可能参与后续操作的一个或两个寄存器，rA和rB。
      * 得到八个字节常数字valC。
      * 计算当前指令的下一条指令的地址valP，等于PC的值加上已取出指令的长度。
    * 译码：从寄存器文件读入最多两个操作数。
      * 读rA或/和rB寄存器得到valA或/和valB。
      * 如果需要读寄存器%rsp。
    * 执行：算术/逻辑单元（ALU）根据取值阶段得到的ifun，执行指令指明的操作，计算内存引用的有效地址；或增加或减少栈指针，得到valE。
      * 可能设置条件码，比如条件传送指令中，根据传送条件ifun和传送值设置条件码。
    * 访存：将数据写入内存或从内存中读出数据，读出的值为valM。
    * 写回：最多可以写两个结果到寄存器文件。
    * 更新PC：将PC设置为下一条指令的地址。

* 不同的Y86-64指令在各个阶段的处理过程。

  * 整数和逻辑运算（OPq）、rrmovq（寄存器-寄存器传送）和irmovq（立即数-寄存器传送）

    <img src="images/Y86-64指令阶段1.png" alt="Y86-64指令阶段1" style="zoom:67%;" />

  * rmmovq（寄存器-内存传送）、mrmovq（内存-寄存器传送）、cmovXX（各种条件传送）

    <img src="images/Y86-64指令阶段2.png" alt="Y86-64指令阶段2" style="zoom:67%;" />

  * pushq（入栈）、popq（出栈）

    * 在pushq指令的阶段编写中，为了和之前确认的规则一致，即歧义指令`pushq %rsp`的执行应该将寄存器%rsp的原始值压入栈，故在访存阶段，将valA写回内存中。
    * 在popq指令的阶段编写中，为了和之前确认的规则一致，即歧义指令`popq %rsp`的执行应该将寄存器%rsp的值设置为从内存中读出的值，故在写回阶段，先写回valE再写回valM。

    <img src="images/Y86-64指令阶段3.png" alt="Y86-64指令阶段3" style="zoom: 50%;" />

  * jXX（各种跳转）、call（调用）、ret（返回）

    * 跳转指令需要在执行阶段，检查条件码和跳转条件，产生一个一位信号Cnd，在更新PC阶段，根据产生的Cnd信号决定下一条将要执行的地址。
    * 调用指令（call）需要将call指令后紧跟的那条指令的地址压入栈， 在更新PC时，将PC设置为调用的目的地（valC）。
    * 返回指令（ret）在更新阶段需要将从栈里取出的值，赋值给PC。

    <img src="images/Y86-64指令阶段4.png" alt="Y86-64指令阶段4" style="zoom: 67%;" />

* SEQ处理器硬件结构的抽象表示

  * Y86-64所有指令的计算被组织为6个基本阶段：取指、译码、执行、访存、写回、更新PC。
  * 每个阶段有相对应的硬件负责处理本阶段的工作。
  * 信息沿着线流动，先向上，再向右。
  * 反馈线路向下，包括要写到寄存器文件的更新值，以及更新的程序计数器值。
  * 从下往上画处理器和流程的方法，有利于后面设计流水线化的处理器。

  <img src="images/Seq处理器硬件结构抽象图.png" alt="Seq处理器硬件结构抽象图" style="zoom:67%;" />

* 一个较为详细的SEQ处理器硬件结构的表示

  * 白色方框表示时钟寄存器（由时钟信号控制寄存器加载输入值），图中唯一的时钟寄存器是PC。
  * 浅蓝色方框表示硬件单元，如ALU等，在这里把它们当做黑盒，不关注其内部具体的实现细节。
  * 灰色圆角矩形表示控制逻辑块，用于从一组信号源中进行选择，或者用来计算一些布尔函数。
  * 白色圆圈表示线路的名字。
  * 中等粗度的线表示宽度为字长的数据连接，表示将一个字从硬件的一部分传送到另一部分。
  * 细线表示宽度为字节或更窄的数据连接。根据具体的数据类型，选择传递的字节数。
  * 虚线表示单个位的连接。代表芯片上单元与块之间传递的控制值。

  ![Seq处理器硬件结构详图](images/Seq处理器硬件结构详图.png)

* 硬件设计和指令阶段之间的映射

  * 在硬件的设计工作中，要将计算映射到硬件上，需要实现控制逻辑，它能在不同硬件单元之间传送数据，以及操作这些单元，使得对每个不同的指令执行指定的运算。
  * 可以说，在这里硬件设计的重中之重是控制逻辑的设计。
  * 除了之前介绍的操作存储设备和算术/逻辑单元的信号外，新引入四个寄存器ID信号：srcA、valA的源；srcB、valB的源；dstE，写入valE的寄存器；以及dstM，写入valM的寄存器。

* SEQ的时序控制

  * 目的：由于一个时钟变化会引发一个经过组合逻辑的流，来执行整个指令，而像之前说的存在一些硬件单元（如时钟寄存器、寄存器文件等），它们所执行的操作是和时钟密切相关的，所以需要对它们的时序进行明确说明。
  * 指令内存可以看出和组合逻辑一样的操作。（因为只读，不考虑时序变化对它的影响）
  * 程序寄存器、条件码寄存器、数据内存和寄存器文件的时序需要进行明确的控制，使得它们也可以像组合逻辑电路一样，输入一个地址产生输出的字。
  * 遵循从不回读原则
    * 目的：保证即使所有的寄存器状态更新实际上同时发生，指令内的赋值顺序并不会因此而发生改变。
    * 处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。
  * 每个周期开始时，状态单元（程序计数器、条件码寄存器、寄存器文件以及数据内存）是根据前一条指令设置的。信号传播通过组合逻辑，创建出新的状态单元的值。在下一个周期开始时，这些值会被加载到状态单元里。状态单元的写操作只在时钟的上升阶段执行。

* HCL描述中使用的常数值，这些值表示的是指令、功能码、寄存器ID、ALU操作和状态码的编码。

  |  名称   | 值（十六进制） |           含义           |
  | :-----: | :------------: | :----------------------: |
  |  IHALT  |       0        |      halt指令的代码      |
  |  INOP   |       1        |      nop指令的代码       |
  | IRRMOVQ |       2        |     rrmovq指令的代码     |
  | IIRMOVQ |       3        |     irmovq指令的代码     |
  | IRMMOVQ |       4        |     rmmovq指令的代码     |
  | IMRMOVQ |       5        |     mrmovq指令的代码     |
  |  IOPL   |       6        |    整数运算指令的代码    |
  |  IJXX   |       7        |      跳转指令的代码      |
  |  ICALL  |       8        |      call指令的代码      |
  |  IRET   |       9        |      ret指令的代码       |
  | IPUSHQ  |       A        |     pushq指令的代码      |
  |  IPOPQ  |       B        |      popq指令的代码      |
  |  FNONE  |       0        |        默认功能码        |
  |  RRSP   |       4        |       %rsp寄存器ID       |
  |  RNONE  |       F        | 表明没有寄存器文件的访问 |
  | ALUADD  |       0        |      加法运算的功能      |
  |  SAOK   |       1        |      正常操作状态码      |
  |  SADR   |       2        |      地址异常状态码      |
  |  SINS   |       3        |    非法指令异常状态码    |
  |  SHLT   |       4        |        halt状态码        |

  * nop指令除了将PC加1，不进行任何处理。
  * halt指令使得处理器的状态被设置为HLT，导致处理器停止运行。

* SEQ各阶段控制逻辑的详细实现：取指阶段

  <img src="images/取指阶段详细设计.png" alt="取指阶段详细设计" style="zoom:67%;" />

  * 从指令内存中获取指令，得到的第一个字节
    * 经过Split硬件单元分为两个4位的数，经过icode和ifun两个控制逻辑块计算指令和功能码。
    * 访问指令内存越界时，产生信号imem_error。
  * 获得的指令icode信号，分别经过Instr valid、Need valC和Need regids三个控制逻辑块的计算产生对应的三个信号：
    * instr_valid：这个字节对应于一个合法的Y86-64指令吗？
    * need_valC：这个指令包括一个常数数字吗？
    * need_regids：这个指令包括一个寄存器指示符字节吗？
  * 结合信号imem_error和instr_valid的值，在访存阶段用于产生状态码。
  * 从指令内存中获取指令的剩下9个字节
    * 经过Align硬件单元计算处理，根据信号值的不同，执行不同的操作
      * 当信号need_regids为1时，字节1被分开装入寄存器指示符rA和rB中，否则rA和rB信号的值为0xF。
      * 结合信号need_regids和need_valC的值，判断是否产生常数值信号valC，以及根据指令中的哪8位产生。
      * 结合信号need_regids和need_valC的值，产生信号valP。

* SEQ各阶段控制逻辑的详细实现：译码阶段和写回

  <img src="images/译码和写回阶段的详细设计.png" alt="译码和写回阶段的详细设计" style="zoom:67%;" />

  * 这两个阶段都需要访问寄存器文件，寄存器文件支持同时进行两个读（在端口A和B上）和两个写（在端口E和M上），每个端口都有一个地址连接和一个数据连接。两个读端口的地址输入为srcA和srcB，两个写端口的地址输入为dstE和dstM，如果输入的地址为0xF表示不需要访问寄存器。
  * 根据指令代码icode，寄存器的指示值rA和rB，执行阶段产生的Cnd条件信号，决定寄存器ID（srcA，srcB，dstE和dstM）的值。

* SEQ各阶段控制逻辑的详细实现：执行阶段

  <img src="images/执行阶段的详细设计.png" alt="执行阶段的详细设计" style="zoom:67%;" />

  * 对操作数aluA和aluB的设置，为了保证运算顺序，aluB在前，aluA在后，根据指令的类型，aluA的值可以是valA、valC或者8、-8。
  * ALU单元根据信号alufun的值，决定对输入aluA和aluB执行运算操作的类型。根据icode信号的值，alufun信号一般为ADD，只用在指令为OPq时，才将alufun信号设置为ifun字段中编码的操作值。
  * 设置信号set_cc来控制是否应该更新条件码寄存器，只有在执行OPq指令时，才设置条件码。
  * 硬件单元cond根据条件码信号和功能码（ifun）信号的值，产生信号Cnd，该信号表示是否进行条件分支或者条件数据传送。

* SEQ各阶段控制逻辑的详细实现：访存阶段

  <img src="images/访存阶段详细设计.png" alt="访存阶段详细设计" style="zoom:67%;" />

  * 在本阶段中，读或者写程序数据。
  * 其中，Mem addr和Mem data这两个控制块产生内存地址和内存输入数据（写操作）的值
  * Mem write和Mem read这两个控制块产生表明应该进行读操作还是写操作的控制信号，当执行读操作时，数据内存产生值valM。
  * 最后，根据取指阶段产生的icode、imem_error、instr_valid值以及数据内存产生的dmem_error信号，计算状态码Stat。

* SEQ各阶段控制逻辑的详细实现：更新PC阶段

  <img src="images/更新PC阶段详细设计.png" alt="更新PC阶段详细设计" style="zoom:67%;" />

  * 根据指令的类型和是否要选择分支，新的PC可能是valC、valM和valP。

## 流水线通用原理

> 流水线在生活中有非常多的应用， 流水线化的一个重要特征是提高了系统的吞吐量，也就是单位时间内服务的数量，但也会轻微增加延迟，即有些程序并不需要流水线的一些部分，但也必须走完所有的既定流程。

* 延迟和吞吐量

  * 延迟：从头到尾执行一条指令所需要的时间，一般的，在现代逻辑设计中，电路延迟以皮秒为单位，即$10^{-12}s$。
  * 吞吐量：延迟的倒数，即每秒可以运行多少条指令，一般的，在现代逻辑设计中，以每秒千兆条指令（GIPS），也就是每秒十亿条指令，$10^9$，为单位来描述吞吐量。

* 流水线处理器

  * 将指令的执行分为相同的阶段，每个阶段占用一个时钟周期。

  * 各阶段之间增加流水线寄存器。用于保存不同指令在本阶段产生的输出，用于下一个阶段的计算。

  * 由时钟信号控制流水线之间的指令转移。

  * 如图所示，是一个简单的流水线处理器的例子，包含了三个阶段，两个流水线寄存器，时钟周期为120。

    <img src="images/流水线处理器.png" alt="流水线处理器" style="zoom:67%;" />

    * 在时刻240时钟上升之前，阶段A中计算的指令I2的值已经到达第一个流水线寄存器的输入，但是该寄存器的状态和输出还保持为指令I1在阶段A中计算的值。同时，指令I1在阶段在阶段B中计算的值已经到达第二个流水线寄存器的输入。如下图中过程1所示。
    * 当时钟上升时，这些输入被加载到流水线寄存器中，成为寄存器的输入。同时阶段A的输入被设置成发起指令I3的计算。如下图中过程2所示。
    * 信号传播通过各个阶段的组合逻辑。如下图中过程3所示。
    * 在时刻360之前，结果值到达流水线寄存器的输入。如下图中过程4所示。
    * 当时刻360时钟上升时，各条指令继续经过下一个流水线阶段。周而复始。

    ![流水线的详细过程](images/流水线的详细过程.png)

* 流水线的局限性，现实中的流水线并不总是那么理想，每个阶段所占的时间可能不是平均分配的，因此会给流水线本身带来一些影响。

  * 不一致的划分（短板效应）

    运行时钟的速率是由最慢阶段的延迟限制的，同时它也决定着整个时钟周期的时间。再加上处理器中的某些硬件单元是不能被划分成多个延迟较小的单元，这使得平衡创建很困难。

    <img src="images/不一致的划分对流水线的影响.png" alt="不一致的划分对流水线的影响" style="zoom:67%;" />

  * 流水线过深，收益反而下降

    虽然划分的阶段越多，处理器的吞吐量越大，但这不意味着性能越好，因为划分需要在阶段中间增加流水线寄存器，该寄存器的读和写也具有一定的延迟，这在一定程度上会增加整个处理器的延迟。可以说正是由于流水线寄存器的延迟，使得吞吐量增加的倍数不等于流水线的阶段数。

* 将流水线引入含有反馈路径的系统（SEQ系统）中的危险

  * 相邻指令之间可能存在数据相关，即第二条指令需要读第一条指令写的寄存器。
  * 跳转指令产生的控制相关，条件测试的结果会决定下一条要执行的指令。
  * 所谓“含有反馈路径的系统”是指，在前面的SEQ系统中，使用反馈线路，将寄存器的更新值写到寄存器文件，以及更新的程序计数器值。（写回和更新PC阶段）

