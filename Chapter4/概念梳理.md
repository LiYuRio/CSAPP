# 处理器体系结构

> 专注于梳理本章中出现的重要概念，对概念的描述尽量做到述而不作，避免因为个人理解偏差对其他人造成误导。
>
> 本章将简要介绍处理器硬件的设计，研究一个硬件系统执行某种ISA指令的方法。

* 指令集体系结构（Instruction Set Architecture，ISA）

  * 描述一个处理器**支持的指令**和**指令的字节级编码**。
  * 为编译器编写者和处理器设计者提供概念抽象层。（相当于一层封装解耦）
  * 不同处理器家族有不同的指令集体系结构，如`x86-64`、`ARM`。

* Y86-64指令集

  受x86-64指令集的启发，创建该简化指令集。与x86-64指令集相比；

  * 数据类型、指令和寻址方式比较少
  * 字节级编码比较简单
  * 机器代码相对不那么紧凑，CPU译码逻辑也相对简单
  * 但结构完整，可以写一些处理整数的程序

* 硬件控制语言（HCL）

  描述硬件系统控制部分的简单语言。

## Y86-64指令集体系结构

> 定义Y86-64指令集体系结构中的各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

* 程序员可见状态

  程序中的每条指令都会读取或修改处理器状态的某些部分。Y86-64的程序员可见状态包括：

  * 15个程序寄存器，每个程序寄存器存储一个64位的字。存储在CPU中的一个寄存器文件中。

  * 程序寄存器的指示符字节编码如下表所示

    | 程序寄存器   | ID   |
    | :----------- | :--- |
    | %rax         | 0    |
    | %rcx         | 1    |
    | %rdx         | 2    |
    | %rbx         | 3    |
    | %rsp         | 4    |
    | %rbp         | 5    |
    | %rsi         | 6    |
    | %rdi         | 7    |
    | %r8          | 8    |
    | %r9          | 9    |
    | %r10         | A    |
    | %r11         | B    |
    | %r12         | C    |
    | %r13         | D    |
    | %r14         | E    |
    | 无寄存器访问 | F    |

  * 程序计数器（PC）

  * 条件码寄存器：包括3个一位的条件码，ZF、SF和OF。保存最近的算术或逻辑指令所造成影响的有关信息。

  * 内存，用虚拟地址指明数据实际在内存中的存储位置。

  * 状态码（Stat）：程序执行的整体状态。

* Y86-64指令

  * 将MOV指令根据目的和源的格式，分为4种，不支持内存间和立即数到内存的传送。
  * 整数操作指令，分为4种
  * 根据分支指令的类型和条件代码的设置来选择分支，跳转指令分为7种。目的地址采用绝对编码方式（相比于IA32的相对寻址方式）
  * 条件传送指令，分为6种，只有条件码满足所需要的约束时，才会更新目的寄存器的值
  * 函数的调用和返回指令，调用指令的目的地址采用绝对编码方式（相比于IA32的相对寻址方式）
  * 与栈操作相关的入栈和出栈指令
  * 停止指令的执行的指令
  * 空指令

  <img src="images/Y86-64指令集.png" alt="Y86-64指令集" style="zoom:80%;" />

* Y86-64指令编码由1~10个字节组成。

  * 第一个字节：指令的类型
    * 高4位代表代码
    * 低4位代表功能，区分共用代码的相关指令
  * 第二个字节：寄存器指示符字节，具体和程序寄存器表中的字节表示对应。
  * 后四个字节：常数字，代表操作数或绝对地址。
  * 指令中的所有整数采用小端法编码，即当按照反汇编格式书写，字节以相反的顺序出现。
  * 字节编码和指令必须一一对应。
  
* CISC和早期的RISC

  | CISC                                                         | 早期的RISC                                                   |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 指令数量很多                                                 | 指令数量少很多，通常少于100个。                              |
  | 有些指令的延迟很长，如将一整块从内存的一部分复制到另一部分   | 没有较长延迟的指令，有些早期的RISC机器甚至没有整数乘法指令。 |
  | 编码是可变长度的，x86-64的指令长度通常是1~15个字节           | 编码是固定长度的，通常所有指令都编码为4个字节                |
  | 指定操作数的方法有很多                                       | 简单寻址方式，通常只有基址和偏移量寻址                       |
  | 可以对内存和寄存器操作数进行算术和逻辑运算                   | 只能对寄存器操作进行算术逻辑运算，允许使用内存的只有load和store指令，这种方法称为load/store体系 |
  | 对机器级程序来说，实现细节是不可见的，ISA提供程序和如何执行程序之间的清晰的抽象。 | 对机器级程序来说实现细节是可见的                             |
  | 有条件码，作为指令执行的副产品，设置了一些特殊的标志位，可以用于条件分支检测。 | 没有条件码，对条件检测来说，要明确测试指令，将测试结果放在一个普通寄存器中。 |
  | 栈密集的过程链接，栈被用来存取过程参数和返回地址             | 寄存器密集的过程链接，因此有些过程能完全避免内存引用。       |

  Y86-64指令集可以看成是采用CISC指令集，但又根据某些RISC的原理进行了简化。

* Y86-64指令集状态码（Stat）可能的值

  | 状态码值 | 名字 | 含义                            |
  | -------- | ---- | ------------------------------- |
  | 1        | AOK  | 正常操作                        |
  | 2        | HLT  | 处理器执行halt指令              |
  | 3        | ADR  | 处理器遇到非法内存地址（读/写） |
  | 4        | INS  | 处理器遇到非法指令代码          |

  除AOK外，状态码等于其他值都意味着，硬件在执行指令时遇到异常，有两种解决方法：

  * 简单粗暴的让处理器停止程序的运行。（Y86-64采用这种方法）
  * 让处理器调用异常处理程序，根据配置的不同结果，中止程序或者调用一个用户自定义的信号处理程序。

* 一个基于Y86-64指令集运行程序的全过程

  * 使用Y86-64定义的指令规则编写对应的汇编代码。其中包含指令、伪指令（指明应该将代码或数据放在什么位置以及如何对齐）、数据。
  * 将汇编代码输入YAS汇编器，输出目标代码。目标代码包含一个地址，后面跟着1~10个字节的值。
  * 通过指令模拟器YIS，模拟Y86-64机器代码程序的执行，而不用去模拟任何具体处理器实现的行为，有助于在有实际硬件可用之前调试程序。

* 两个会对设计产生歧义的指令

  * `pushq %rsp`

    压入的是%rsp寄存器的原始值

  * `popq %rsp`

    将%rsp设置为存内存中读出的值

* 实现一个数字系统，需要三个组成部分

  * 计算对位进行操作的函数的组合逻辑
  * 存储位的存储器单元
  * 控制存储器单元进行更新的时钟信号

* 数字电路的基本计算单元——逻辑门

  * 逻辑门的输出等于输入位值的某个布尔函数，只对单个位的数进行操作
  * HCL写法为：`&&`、`||`、`!`（与、或、非）
  * 逻辑门总是活动的，一旦一个门的输入发生变化，在短时间内，输出也会发生变化。

* 组合电路

  将很多的逻辑门组合成一个网，就能构建计算块，这个计算块被称为组合电路。组合电路的构建有以下三个限制：

  * 这个网必须是无环的。
  * 两个或多个逻辑门的输出不能连接到一起。
  * 每个逻辑门的输入必须连到，一个系统输入、某个存储器单元的输出或者某个逻辑门的输出。

* 多路复用器（multiplexor）

  根据输入的控制信号的值，从一组不同的数据信号中选出一个。下图所示是一个但各位的多路复用器的电路

  <img src="images/单个位的MUX.png" alt="单个位的MUX" style="zoom:80%;" />

* 字级的组合电路

  根据输入字的各个位，用逻辑门来计算输出字的各个位。

* 多路复用器的HCL描述——情况表达式

  ```
  [
  	select1 : expr1
  	select2 : expr2
  	...
  	selectk : exprk
  ]
  ```

  每种情况都包含一个布尔表达式和一个整数表达式，前者表示什么时候选择这个情况，后者表示得到的值。布尔表达式顺序求值，第一个求值为1的情况被选中。

* 算术/逻辑单元（ALU）

  在字级数据上执行许多不同类型的操作的组合逻辑电路，ALU有两个数据输入和一个控制输入，根据控制输入的设置，电路会对数据输入执行不同的算术逻辑运算，Y86-64指令集支持的四种不同的整数运算的ALU抽象表示如下图所示：

  <img src="images/Y86-64的ALU.png" alt="Y86-64的ALU" style="zoom:80%;" />

* 集合关系的HCL描述

  * 应用场景：在处理器的设计中，很多时候都需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。

  * 通用格式为

    ```
    iexpr in {iexpr1, iexpr2, ..., iexprk
    ```

    其中iexpr为整数表达式。

* 

