# 处理器体系结构

> 专注于梳理本章中出现的重要概念，对概念的描述尽量做到述而不作，避免因为个人理解偏差对其他人造成误导。
>
> 本章将简要介绍处理器硬件的设计，研究一个硬件系统执行某种ISA指令的方法。

* 指令集体系结构（Instruction Set Architecture，ISA）

  * 描述一个处理器**支持的指令**和**指令的字节级编码**。
  * 为编译器编写者和处理器设计者提供概念抽象层。（相当于一层封装解耦）
  * 不同处理器家族有不同的指令集体系结构，如`x86-64`、`ARM`。

* Y86-64指令集

  受x86-64指令集的启发，创建该简化指令集。与x86-64指令集相比；

  * 数据类型、指令和寻址方式比较少
  * 字节级编码比较简单
  * 机器代码相对不那么紧凑，CPU译码逻辑也相对简单
  * 但结构完整，可以写一些处理整数的程序

* 硬件控制语言（HCL）

  描述硬件系统控制部分的简单语言。

## Y86-64指令集体系结构

> 定义Y86-64指令集体系结构中的各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理。

* 程序员可见状态

  程序中的每条指令都会读取或修改处理器状态的某些部分。Y86-64的程序员可见状态包括：

  * 15个程序寄存器，每个程序寄存器存储一个64位的字。存储在CPU中的一个寄存器文件中。

  * 程序寄存器的指示符字节编码如下表所示

    | 程序寄存器   | ID   |
    | :----------- | :--- |
    | %rax         | 0    |
    | %rcx         | 1    |
    | %rdx         | 2    |
    | %rbx         | 3    |
    | %rsp         | 4    |
    | %rbp         | 5    |
    | %rsi         | 6    |
    | %rdi         | 7    |
    | %r8          | 8    |
    | %r9          | 9    |
    | %r10         | A    |
    | %r11         | B    |
    | %r12         | C    |
    | %r13         | D    |
    | %r14         | E    |
    | 无寄存器访问 | F    |

  * 程序计数器（PC）

  * 条件码寄存器：包括3个一位的条件码，ZF、SF和OF。保存最近的算术或逻辑指令所造成影响的有关信息。

  * 内存，用虚拟地址指明数据实际在内存中的存储位置。

  * 状态码（Stat）：程序执行的整体状态。

* Y86-64指令

  * 将MOV指令根据目的和源的格式，分为4种，不支持内存间和立即数到内存的传送。
  * 整数操作指令，分为4种
  * 根据分支指令的类型和条件代码的设置来选择分支，跳转指令分为7种。目的地址采用绝对编码方式（相比于IA32的相对寻址方式）
  * 条件传送指令，分为6种，只有条件码满足所需要的约束时，才会更新目的寄存器的值
  * 函数的调用和返回指令，调用指令的目的地址采用绝对编码方式（相比于IA32的相对寻址方式）
  * 与栈操作相关的入栈和出栈指令
  * 停止指令的执行的指令
  * 空指令

  <img src="images/Y86-64指令集.png" alt="Y86-64指令集" style="zoom:80%;" />

* Y86-64指令编码由1~10个字节组成。

  * 第一个字节：指令的类型
    * 高4位代表代码
    * 低4位代表功能，区分共用代码的相关指令
  * 第二个字节：寄存器指示符字节，具体和程序寄存器表中的字节表示对应。
  * 后四个字节：常数字，代表操作数或绝对地址。
  * 指令中的所有整数采用小端法编码，即当按照反汇编格式书写，字节以相反的顺序出现。
  * 字节编码和指令必须一一对应。